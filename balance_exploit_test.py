#!/usr/bin/env python3
"""
CRITICAL BALANCE EXPLOIT TEST
=============================

This test specifically verifies the fix for the balance exploit where users could
potentially increase their balance by creating and cancelling bets repeatedly.

Test Scenario:
1. Login as admin@gemplay.com / Admin123!
2. Get initial balance (virtual_balance, frozen_balance)
3. Create game with Ruby 25 gems on $25
4. Check that 6% commission ($1.50) is frozen in frozen_balance
5. Check that virtual_balance does NOT change
6. Cancel the game
7. CRITICALLY: Check that balance after cancellation is exactly the same as before creation
8. Ensure no infinite balance growth through create/cancel operations
"""

import requests
import json
import time
import sys
from typing import Dict, Any, Optional, Tuple

# Configuration
BASE_URL = "https://pishi-po-russki.preview.emergentagent.com/api"
ADMIN_USER = {
    "email": "admin@gemplay.com",
    "password": "Admin123!"
}

# Test results tracking
test_results = {
    "total": 0,
    "passed": 0,
    "failed": 0,
    "tests": []
}

# Colors for terminal output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(text: str) -> None:
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 80}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(80)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'=' * 80}{Colors.ENDC}\n")

def print_subheader(text: str) -> None:
    """Print a formatted subheader."""
    print(f"\n{Colors.OKBLUE}{Colors.BOLD}{text}{Colors.ENDC}")
    print(f"{Colors.OKBLUE}{'-' * 80}{Colors.ENDC}\n")

def print_success(text: str) -> None:
    """Print a success message."""
    print(f"{Colors.OKGREEN}✓ {text}{Colors.ENDC}")

def print_warning(text: str) -> None:
    """Print a warning message."""
    print(f"{Colors.WARNING}⚠ {text}{Colors.ENDC}")

def print_error(text: str) -> None:
    """Print an error message."""
    print(f"{Colors.FAIL}✗ {text}{Colors.ENDC}")

def record_test(name: str, passed: bool, details: str = "") -> None:
    """Record a test result."""
    test_results["total"] += 1
    if passed:
        test_results["passed"] += 1
        print_success(f"TEST PASSED: {name}")
    else:
        test_results["failed"] += 1
        print_error(f"TEST FAILED: {name} - {details}")
    
    test_results["tests"].append({
        "name": name,
        "passed": passed,
        "details": details
    })

def make_request(
    method: str, 
    endpoint: str, 
    data: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
    expected_status: int = 200,
    auth_token: Optional[str] = None
) -> Tuple[Dict[str, Any], bool]:
    """Make an HTTP request to the API."""
    url = f"{BASE_URL}{endpoint}"
    
    if headers is None:
        headers = {}
    
    if auth_token:
        headers["Authorization"] = f"Bearer {auth_token}"
    
    print(f"Making {method} request to {url}")
    if data:
        print(f"Request data: {json.dumps(data, indent=2)}")
    
    if data and method.lower() in ["post", "put", "patch", "delete"]:
        headers["Content-Type"] = "application/json"
        response = requests.request(method, url, json=data, headers=headers)
    else:
        response = requests.request(method, url, params=data, headers=headers)
    
    print(f"Response status: {response.status_code}")
    
    try:
        response_data = response.json()
        print(f"Response data: {json.dumps(response_data, indent=2)}")
    except json.JSONDecodeError:
        response_data = {"text": response.text}
        print(f"Response text: {response.text}")
    
    success = response.status_code == expected_status
    
    if not success:
        print_error(f"Expected status {expected_status}, got {response.status_code}")
    
    return response_data, success

def get_user_balance(auth_token: str) -> Tuple[float, float]:
    """Get user's virtual_balance and frozen_balance."""
    response, success = make_request("GET", "/economy/balance", auth_token=auth_token)
    
    if success:
        virtual_balance = response.get("virtual_balance", 0.0)
        frozen_balance = response.get("frozen_balance", 0.0)
        print(f"Current balance - Virtual: ${virtual_balance:.2f}, Frozen: ${frozen_balance:.2f}")
        return virtual_balance, frozen_balance
    else:
        print_error("Failed to get user balance")
        return 0.0, 0.0

def test_critical_balance_exploit_fix() -> None:
    """Test the critical balance exploit fix."""
    print_header("CRITICAL BALANCE EXPLOIT FIX TEST")
    
    # Step 1: Login as admin user
    print_subheader("Step 1: Admin Login")
    
    login_data = {
        "email": ADMIN_USER["email"],
        "password": ADMIN_USER["password"]
    }
    
    response, success = make_request("POST", "/auth/login", data=login_data)
    
    if not success or "access_token" not in response:
        print_error("Failed to login as admin - cannot proceed with balance exploit test")
        record_test("Admin Login", False, "Admin login failed")
        return
    
    admin_token = response["access_token"]
    print_success(f"Admin logged in successfully")
    record_test("Admin Login", True)
    
    # Step 2: Get initial balance state
    print_subheader("Step 2: Get Initial Balance State")
    
    initial_virtual_balance, initial_frozen_balance = get_user_balance(admin_token)
    
    if initial_virtual_balance == 0 and initial_frozen_balance == 0:
        print_error("Failed to get initial balance - cannot proceed")
        record_test("Get Initial Balance", False, "Failed to retrieve balance")
        return
    
    print_success(f"Initial state captured - Virtual: ${initial_virtual_balance:.2f}, Frozen: ${initial_frozen_balance:.2f}")
    record_test("Get Initial Balance", True)
    
    # Step 3: Ensure admin has Ruby gems for testing
    print_subheader("Step 3: Ensure Ruby Gems Available")
    
    # Check current gem inventory
    inventory_response, inventory_success = make_request("GET", "/gems/inventory", auth_token=admin_token)
    
    ruby_available = 0
    if inventory_success:
        for gem in inventory_response:
            if gem["type"] == "Ruby":
                ruby_available = gem["quantity"] - gem["frozen_quantity"]
                break
    
    # Buy Ruby gems if needed (need 25 for the test)
    if ruby_available < 25:
        gems_to_buy = 25 - ruby_available
        print(f"Need to buy {gems_to_buy} Ruby gems for testing")
        
        buy_response, buy_success = make_request(
            "POST", 
            f"/gems/buy?gem_type=Ruby&quantity={gems_to_buy}",
            auth_token=admin_token
        )
        
        if buy_success:
            print_success(f"Successfully bought {gems_to_buy} Ruby gems")
            record_test("Buy Ruby Gems", True)
        else:
            print_error("Failed to buy Ruby gems for testing")
            record_test("Buy Ruby Gems", False, "Failed to buy gems")
            return
    else:
        print_success(f"Sufficient Ruby gems available: {ruby_available}")
        record_test("Ruby Gems Available", True)
    
    # Step 4: Create game with Ruby 25 gems ($25 bet)
    print_subheader("Step 4: Create Game with Ruby 25 Gems ($25 bet)")
    
    bet_gems = {"Ruby": 25}  # 25 Ruby gems at $1 each = $25 total
    expected_bet_amount = 25.0
    expected_commission = expected_bet_amount * 0.06  # 6% = $1.50
    
    create_game_data = {
        "move": "rock",
        "bet_gems": bet_gems
    }
    
    print(f"Creating game with bet: {bet_gems}")
    print(f"Expected bet amount: ${expected_bet_amount}")
    print(f"Expected commission: ${expected_commission:.2f}")
    
    game_response, game_success = make_request(
        "POST", "/games/create",
        data=create_game_data,
        auth_token=admin_token
    )
    
    if not game_success or "game_id" not in game_response:
        print_error("Failed to create game")
        record_test("Create Game", False, "Game creation failed")
        return
    
    game_id = game_response["game_id"]
    actual_bet_amount = game_response.get("bet_amount", 0)
    actual_commission = game_response.get("commission_reserved", 0)
    
    print_success(f"Game created successfully with ID: {game_id}")
    print_success(f"Actual bet amount: ${actual_bet_amount}")
    print_success(f"Actual commission reserved: ${actual_commission}")
    
    # Verify bet amount is correct
    if abs(actual_bet_amount - expected_bet_amount) < 0.01:
        print_success("✓ Bet amount is correct")
        record_test("Correct Bet Amount", True)
    else:
        print_error(f"✗ Bet amount mismatch: Expected ${expected_bet_amount}, got ${actual_bet_amount}")
        record_test("Correct Bet Amount", False, f"Amount mismatch")
    
    # Verify commission is correct
    if abs(actual_commission - expected_commission) < 0.01:
        print_success("✓ Commission amount is correct")
        record_test("Correct Commission Amount", True)
    else:
        print_error(f"✗ Commission mismatch: Expected ${expected_commission:.2f}, got ${actual_commission}")
        record_test("Correct Commission Amount", False, f"Commission mismatch")
    
    record_test("Create Game", True)
    
    # Step 5: Check balance after game creation
    print_subheader("Step 5: Check Balance After Game Creation")
    
    after_create_virtual_balance, after_create_frozen_balance = get_user_balance(admin_token)
    
    # CRITICAL CHECK 1: virtual_balance should NOT change
    virtual_balance_change = after_create_virtual_balance - initial_virtual_balance
    if abs(virtual_balance_change) < 0.01:
        print_success("✓ CRITICAL: virtual_balance did NOT change during game creation")
        record_test("Virtual Balance Unchanged", True)
    else:
        print_error(f"✗ CRITICAL: virtual_balance changed by ${virtual_balance_change:.2f} during game creation")
        record_test("Virtual Balance Unchanged", False, f"Changed by ${virtual_balance_change:.2f}")
    
    # CRITICAL CHECK 2: frozen_balance should increase by commission amount
    frozen_balance_change = after_create_frozen_balance - initial_frozen_balance
    if abs(frozen_balance_change - expected_commission) < 0.01:
        print_success(f"✓ CRITICAL: frozen_balance correctly increased by ${frozen_balance_change:.2f}")
        record_test("Frozen Balance Increased Correctly", True)
    else:
        print_error(f"✗ CRITICAL: frozen_balance change incorrect. Expected ${expected_commission:.2f}, got ${frozen_balance_change:.2f}")
        record_test("Frozen Balance Increased Correctly", False, f"Wrong change: ${frozen_balance_change:.2f}")
    
    # Step 6: Cancel the game
    print_subheader("Step 6: Cancel the Game")
    
    print(f"Cancelling game with ID: {game_id}")
    
    cancel_response, cancel_success = make_request(
        "DELETE", f"/games/{game_id}/cancel",
        auth_token=admin_token
    )
    
    if not cancel_success:
        print_error("Failed to cancel game")
        record_test("Cancel Game", False, "Cancel request failed")
        return
    
    # Verify cancel response structure
    if cancel_response.get("success") == True:
        print_success("✓ Cancel operation reported as successful")
        record_test("Cancel Success Flag", True)
    else:
        print_error(f"✗ Cancel operation success flag is: {cancel_response.get('success')}")
        record_test("Cancel Success Flag", False, f"Success flag: {cancel_response.get('success')}")
    
    # Check gems returned
    gems_returned = cancel_response.get("gems_returned", {})
    if gems_returned.get("Ruby") == 25:
        print_success("✓ Correct gems returned: 25 Ruby")
        record_test("Gems Returned Correctly", True)
    else:
        print_error(f"✗ Incorrect gems returned: {gems_returned}")
        record_test("Gems Returned Correctly", False, f"Wrong gems: {gems_returned}")
    
    # Check commission returned
    commission_returned = cancel_response.get("commission_returned", 0)
    if abs(commission_returned - expected_commission) < 0.01:
        print_success(f"✓ Correct commission returned: ${commission_returned:.2f}")
        record_test("Commission Returned Correctly", True)
    else:
        print_error(f"✗ Incorrect commission returned: ${commission_returned:.2f}, expected ${expected_commission:.2f}")
        record_test("Commission Returned Correctly", False, f"Wrong commission: ${commission_returned:.2f}")
    
    record_test("Cancel Game", True)
    
    # Step 7: CRITICAL CHECK - Balance after cancellation
    print_subheader("Step 7: CRITICAL CHECK - Balance After Cancellation")
    
    final_virtual_balance, final_frozen_balance = get_user_balance(admin_token)
    
    # CRITICAL CHECK 3: virtual_balance should be exactly the same as initial
    virtual_balance_final_change = final_virtual_balance - initial_virtual_balance
    if abs(virtual_balance_final_change) < 0.01:
        print_success("✓ CRITICAL: virtual_balance is exactly the same as before game creation")
        record_test("Virtual Balance Restored Exactly", True)
    else:
        print_error(f"✗ CRITICAL EXPLOIT: virtual_balance changed by ${virtual_balance_final_change:.2f} after full cycle")
        record_test("Virtual Balance Restored Exactly", False, f"EXPLOIT: Changed by ${virtual_balance_final_change:.2f}")
    
    # CRITICAL CHECK 4: frozen_balance should be exactly the same as initial
    frozen_balance_final_change = final_frozen_balance - initial_frozen_balance
    if abs(frozen_balance_final_change) < 0.01:
        print_success("✓ CRITICAL: frozen_balance is exactly the same as before game creation")
        record_test("Frozen Balance Restored Exactly", True)
    else:
        print_error(f"✗ CRITICAL EXPLOIT: frozen_balance changed by ${frozen_balance_final_change:.2f} after full cycle")
        record_test("Frozen Balance Restored Exactly", False, f"EXPLOIT: Changed by ${frozen_balance_final_change:.2f}")
    
    # Step 8: Test for infinite balance growth exploit
    print_subheader("Step 8: Test for Infinite Balance Growth Exploit")
    
    print("Testing multiple create/cancel cycles to detect balance growth exploit...")
    
    cycles_to_test = 3
    balance_changes = []
    
    for cycle in range(cycles_to_test):
        print(f"\n--- Cycle {cycle + 1} ---")
        
        # Get balance before cycle
        before_cycle_virtual, before_cycle_frozen = get_user_balance(admin_token)
        
        # Create game
        cycle_game_response, cycle_game_success = make_request(
            "POST", "/games/create",
            data=create_game_data,
            auth_token=admin_token
        )
        
        if not cycle_game_success:
            print_error(f"Failed to create game in cycle {cycle + 1}")
            break
        
        cycle_game_id = cycle_game_response["game_id"]
        
        # Cancel game immediately
        cycle_cancel_response, cycle_cancel_success = make_request(
            "DELETE", f"/games/{cycle_game_id}/cancel",
            auth_token=admin_token
        )
        
        if not cycle_cancel_success:
            print_error(f"Failed to cancel game in cycle {cycle + 1}")
            break
        
        # Get balance after cycle
        after_cycle_virtual, after_cycle_frozen = get_user_balance(admin_token)
        
        # Calculate balance change for this cycle
        virtual_change = after_cycle_virtual - before_cycle_virtual
        frozen_change = after_cycle_frozen - before_cycle_frozen
        
        balance_changes.append({
            "cycle": cycle + 1,
            "virtual_change": virtual_change,
            "frozen_change": frozen_change
        })
        
        print(f"Cycle {cycle + 1} - Virtual change: ${virtual_change:.2f}, Frozen change: ${frozen_change:.2f}")
    
    # Analyze balance changes for exploit patterns
    total_virtual_change = sum(change["virtual_change"] for change in balance_changes)
    total_frozen_change = sum(change["frozen_change"] for change in balance_changes)
    
    print(f"\nTotal balance change after {cycles_to_test} cycles:")
    print(f"Virtual balance change: ${total_virtual_change:.2f}")
    print(f"Frozen balance change: ${total_frozen_change:.2f}")
    
    # CRITICAL CHECK 5: No balance growth through repeated operations
    if abs(total_virtual_change) < 0.01 and abs(total_frozen_change) < 0.01:
        print_success("✓ CRITICAL: No balance growth detected through repeated create/cancel operations")
        record_test("No Infinite Balance Growth", True)
    else:
        print_error(f"✗ CRITICAL EXPLOIT: Balance growth detected! Virtual: ${total_virtual_change:.2f}, Frozen: ${total_frozen_change:.2f}")
        record_test("No Infinite Balance Growth", False, f"EXPLOIT: Virtual: ${total_virtual_change:.2f}, Frozen: ${total_frozen_change:.2f}")
    
    # Final verification
    print_subheader("Final Verification")
    
    final_check_virtual, final_check_frozen = get_user_balance(admin_token)
    
    total_virtual_drift = final_check_virtual - initial_virtual_balance
    total_frozen_drift = final_check_frozen - initial_frozen_balance
    
    print(f"Total drift from initial state:")
    print(f"Virtual balance drift: ${total_virtual_drift:.2f}")
    print(f"Frozen balance drift: ${total_frozen_drift:.2f}")
    
    if abs(total_virtual_drift) < 0.01 and abs(total_frozen_drift) < 0.01:
        print_success("✓ FINAL CHECK: Balance is exactly the same as initial state")
        record_test("Final Balance Verification", True)
    else:
        print_error(f"✗ FINAL CHECK: Balance has drifted from initial state")
        record_test("Final Balance Verification", False, f"Drift: Virtual ${total_virtual_drift:.2f}, Frozen ${total_frozen_drift:.2f}")

def print_summary() -> None:
    """Print a summary of all test results."""
    print_header("CRITICAL BALANCE EXPLOIT TEST SUMMARY")
    
    print(f"Total tests: {test_results['total']}")
    print(f"Passed: {Colors.OKGREEN}{test_results['passed']}{Colors.ENDC}")
    print(f"Failed: {Colors.FAIL}{test_results['failed']}{Colors.ENDC}")
    
    if test_results["failed"] > 0:
        print("\nFailed tests:")
        for test in test_results["tests"]:
            if not test["passed"]:
                print(f"{Colors.FAIL}✗ {test['name']}: {test['details']}{Colors.ENDC}")
    
    success_rate = (test_results["passed"] / test_results["total"]) * 100 if test_results["total"] > 0 else 0
    print(f"\nSuccess rate: {Colors.BOLD}{success_rate:.2f}%{Colors.ENDC}")
    
    # Critical assessment
    critical_tests = [
        "Virtual Balance Unchanged",
        "Frozen Balance Increased Correctly", 
        "Virtual Balance Restored Exactly",
        "Frozen Balance Restored Exactly",
        "No Infinite Balance Growth"
    ]
    
    critical_failures = []
    for test in test_results["tests"]:
        if test["name"] in critical_tests and not test["passed"]:
            critical_failures.append(test["name"])
    
    if critical_failures:
        print(f"\n{Colors.FAIL}{Colors.BOLD}CRITICAL FAILURES DETECTED:{Colors.ENDC}")
        for failure in critical_failures:
            print(f"{Colors.FAIL}  - {failure}{Colors.ENDC}")
        print(f"\n{Colors.FAIL}{Colors.BOLD}BALANCE EXPLOIT MAY STILL BE PRESENT!{Colors.ENDC}")
    else:
        print(f"\n{Colors.OKGREEN}{Colors.BOLD}ALL CRITICAL TESTS PASSED - BALANCE EXPLOIT APPEARS TO BE FIXED!{Colors.ENDC}")

if __name__ == "__main__":
    print_header("CRITICAL BALANCE EXPLOIT FIX VERIFICATION")
    print("This test verifies that the balance exploit has been properly fixed.")
    print("The exploit allowed users to increase their balance by creating and cancelling bets.")
    print()
    
    try:
        test_critical_balance_exploit_fix()
    except Exception as e:
        print_error(f"Test execution failed with exception: {e}")
        record_test("Test Execution", False, f"Exception: {e}")
    
    print_summary()
    
    # Exit with appropriate code
    if test_results["failed"] > 0:
        sys.exit(1)
    else:
        sys.exit(0)